=head1 NAME

Perlbal::Manual::Configuration - How to configure Perlbal


=head2 VERSION

Perlbal 1.76.


=head2 DESCRIPTION

By default, perlbal looks for a configuration file at F</etc/perlbal/perlbal.conf>.

You can also point perlbal at a different configuration file with the B<-c> flag.

    $ perlbal -c /home/user/perlbal.conf

B<-c> has the alias B<--conf>.


=head2 Configuration file

A Perlbal's configuration file is a text file where you create pools and services, add servers to pools, set services' parameters and enable/disable services.

Indentation is not mandatory, but it's considered a good practice for readability issues.

Configuration is case insensitive, but it's also a good practice to uppercase all directives.


=head3 Pools

Here's a sample configuration of a pool:

    CREATE POOL mywebsite
        POOL mywebsite ADD 10.0.0.1:80
        POOL mywebsite ADD 10.0.0.2:80

The first line creates a pool called C<mywebsite>. The second and third lines add two different servers to that pool.

From here on you'll be able to use this pool in a service.

Also, note that right after creating the pool, you don't need to specify which pool you're adding servers to, as it is considered to be the active pool:

    CREATE POOL mywebsite
        POOL ADD 10.0.0.1:80
        POOL ADD 10.0.0.2:80


=head4 Configuring a pool in a separate file

You can create a pool in a separate file by using the C<nodefile> parameter:

    CREATE POOL dynamic
        SET nodefile = conf/nodelist.dat

This separate file should contain addresses in the form of C<ip:port>, one per line (empty lines are ignored, as well as comments started by the C<#> sign).

Perlbal will check the file periodically for updates.

The path to the file is relative to where perlbal was started.

Note that:

    SET pool nodefile = none
    (also undef, null, "", '')

...unsets the nodefile, but does not remove current members.

Check F<conf/load-balancer.conf> and F<conf/nodelist.dat> for an example.


=head4 Pool balance method

You can set the pool balance method:

    SET pool balance_method = 'random'

At the present time, C<random> is the only load balancing method available.


=head3 Services

Here's a sample service:

    CREATE SERVICE service_mywebsite
        SET role            = reverse_proxy
        SET pool            = mywebsite
        SET listen          = 10.0.0.3:80

The first line creates a service called C<service_mywebsite>.

On the three following lines we are setting up three parameters for that service (you can see this same example in L<Perlbal::Manual::LoadBalancer> in more detail).


=head3 Setting parameters

You can set parameters via commands of either forms:

    SET <service-name> <param> = <value>
    SET <param> = <value>

For a full list of parameters see L<Perlbal::Manual::LoadBalancer>, L<Perlbal::Manual::ReverseProxy> or L<Perlbal::Manual::WebServer>.


=head4 B<Note on types>:

'bool' values can be set using one of 1, true, yes, on, 0, false, off, or no.

'size' values are in integer bytes, or an integer followed by 'b', 'k', or 'm' (case-insensitive) for bytes, KiB, or MiB.


=head3 Enabling/Disabling services

To enable a service:

    ENABLE service_mywebsite

To disable a service:

    DISABLE service_mywebsite

The lines is what allows you to have several services configured in a file even if they are not currently active (a common scenario is to configure everything on the file and then enable/disable services on-the-fly as required; see L<Perlbal::Manual::Management> for more information on this process).


=head3 Including configuration files

While Perlbal doesn't natively let you include a configuration file within another, one of its core Plugins does.

By using L<Perlbal::Plugin::Include> you can use this feature:

    LOAD include
    INCLUDE = /etc/perlbal/my.conf
    INCLUDE = /etc/perlbal/other.conf /etc/perlbal/*.conf

See L<Perlbal::Plugin::Include> for further examples and more information.


=head3 Expansions

The following things expand/interpolate in config files/commands:

=over 4

=item C<${ip:eth0}>

Expands to the configured IP for interface "eth0". Probably only works on Linux.

=back


=head3 Comments

Comments in Perlbal's configuration files start with a C<#>:

    # this is a comment
    ENABLE myservice # this is also a comment


=head2 Environment variables

=head3 DANGABUILD_DAEMONONLY

Used in C<Makefile.PL>. If set to a true value the modules will not be built.


=head3 DANGABUILD_MODULESONLY

Used in C<Makefile.PL>. If set to a true value only the modules will be built, not the C<perlbal> executable.


=head3 PERLBAL_DEBUG

There are four levels of debugging in Perlbal.

By setting this variable to a value between 0 and 4 (included) you will activate Perbal's debug.

    PERLBAL_DEBUG = 0 # no debug

    PERLBAL_DEBUG = 4 # debug everything


=head4 Debug level 1

You can activate basic debug by setting C<PERLBAL_DEBUG> to 1:

    PERLBAL_DEBUG = 1

The following debugging messages are turned on:

=over 4

=item * When a connection to a backend is closed, L<Perlbal::BackendHTTP> prints C<Backend $self is done; closing...>.

=item * When a connection to a backend is killed, L<Perlbal::ClientProxy> prints C<Client ($self) closing backend ($backend)>.

=item * When an HTTP request fails to be parsed, L<Perlbal::HTTPHeaders> prints C<HTTP parse failure: $reason>.

=item * When the connection is promoted to SSL, L<Perlbal::TCPListener> prints C<  .. socket upgraded to SSL!>.

=back


=head4 Debug level 2

By setting the debug level to 2 you'll get all the messages from level 1.

    PERLBAL_DEBUG = 2

You will also get a few others:

=over 4

=item * When a connection to a backend is opened and ready to be written to, L<Perlbal::BackendHTTP> prints C<Backend $self is writeable!>.

=item * When a response is about to be handled, L<Perlbal::BackendHTTP> prints C<BackendHTTP: handle_response>.

=item * When a backend is ready to be read from, L<Perlbal::BackendHTTP> prints C<Backend $self is readable!>.

=item * When there's an error with the connection to the backend, L<Perlbal::BackendHTTP> prints C<BACKEND event_err>.

=item * Whenever we're determining if we should be sending keep-alive header information back to the client, L<Perlbal::ClientHTTPBase> prints C<ClientHTTPBase::setup_keepalive($self)>.

=item * Whenever the client is ready for more of its file, L<Perlbal::ClientHTTPBase> prints C<REPROXY SSL done>.

=item * Right after we've read a chunk of a file and when a reproxy request is about to be sent, L<Perlbal::ClientHTTPBase> prints C<REPROXY Sent: $sent>.

=item * When we've written all data in the queue (and are about to stop waiting for write notifications), L<Perlbal::ClientHTTPBase> prints C<All writing done to $self>.

=item * Whenever a client proxy is about to be closed, L<Perlbal::ClientProxy> prints C<Perlbal::ClientProxy closed>, followed by a possible C<again> and a possible C<saying $reason>.

=item * When a client has disconnected, L<Perlbal::ClientProxy> prints C<ClientProxy::client_disconnected>.

=item * When a backend requests a client of a high priority request and the client is available, L<Perlbal/Service> prints C<Got from fast queue, in front of $backlog others>.

=item * When a backend requests a client of a normal priority request and the client is available, L<Perlbal/Service> prints C<Backend requesting client, got PRIORITY = $cp->{fd}.>.

=item * When a backend requests a client of a low priority request and the client is available, L<Perlbal/Service> prints C<Backend requesting client, got low priority = $cp->{fd}.>.

=item * When header are being read, L<Perlbal::Socket> prints C<Perlbal::Socket::read_headers($self) is_res=$is_res>.


=back


=head4 Debug level 3

    PERLBAL_DEBUG = 3

By setting the debug level to 3 you'll get all the messages from level 1 and 2 plus the following:

=over 4

=item * Right before response headers are written to the client, L<Perlbal::BackendHTTP> prints C<  writing response headers to client>.

=item * As we're writing to the client, L<Perlbal::BackendHTTP> prints C<  content_length=VALUE> and C<  remain=VALUE>, where the values are C<undef> if they are not defined.

=item * If we're done writing to the client, L<Perlbal::BackendHTTP> prints C<  done.  detaching.>.

=item * Whenever we're determining if we should be sending keep-alive header information back to the client, L<Perlbal::ClientHTTPBase> prints C<  service's persist_client = $persist_client>.

=item * While determining if we should be sending keep-alive header information back to the client, if we were sent C<content-length> or it's a head request, as we're doing a keep alive L<Perlbal::ClientHTTPBase> prints C<  doing keep-alive to client>.

=item * If we're not sending keep-alive header information back ot the client, L<Perlbal::ClientHTTPBase> prints C<  doing connection: close>.

=item * Right after we've finished sending all of the results to the user, L<Perlbal::ClientProxy> prints C<ClientProxy::backend_finished>.

=item * When we've sent a response to a user fully and we need to reset state, L<Perlbal::ClientProxy> prints C<ClientProxy::http_response_sent -- resetting state>.

=item * When we're writing a response to a client, L<Perlbal::ClientProxy> prints C<ClientProxy::event_write>.

=item * After writing a response to a client, if it is still connected and we're triggering trigger our backend to keep reading, L<Perlbal::ClientProxy> prints C<  unstalling backend>.

=item * When reading a request, L<Perlbal::ClientProxy> prints C<ClientProxy::event_read>.

=item * When reading a request and just before we read the headers, L<Perlbal::ClientProxy> prints C<  no headers.  reading.>.

=item * When reading a request, if we're not buffering to disk or we're no longer reading, as we disable reads, L<Perlbal::ClientProxy> prints C<  disabling reads.>.

=item * As we're reading, L<Perlbal::ClientProxy> prints C<  reading $read_size bytes (VALUE bytes remain)>, where C<VALUE bytes remain> can be <undef>.

=item * After each read, L<Perlbal::ClientProxy> prints C<  read $len bytes>.

=item * After we finished reading the request, L<Perlbal::ClientProxy> prints C<  done_reading = $done_reading, backend = BACKEND>, where C<BACKEND> can be C<undef>.

=item * When we send the headers to the backend and it responds before we're done reading from the client, further reads from the client are discarded; in this situation L<Perlbal::ClientProxy> prints C<  already responded.>. If the client continues to send data, L<Perlbal::ClientProxy> prints C<  already responded [2].> and then gives up on reading.

=item * After reading, and having a backend available where we can write to, just before we do, L<Perlbal::ClientProxy> prints C<  got a backend.  sending write to it.>.

=item * After reading, if there's no backend available, L<Perlbal::ClientProxy> prints C<  no backend.  read_ahead = $self->{read_ahead}.>.

=item * If we know we've already started spooling a file to disk and we're about to continue doing so, L<Perlbal::ClientProxy> prints C<  bureason = $self->{bureason}>.

=item * If a backend wasn't available and we're about to request one, L<Perlbal::ClientProxy> prints C<  finally requesting a backend>.

=item * When we're trying to read headers and the client has disconnected, L<Perlbal::Socket> prints C<  client disconnected>.

=item * If we need to remove a trailing C<\r\n> from the headers, L<Perlbal::Socket> prints C<  throwing away leading \r\n>.

=item * If we've read a packet with headers and by the end of it we can't find the end of them, L<Perlbal::Socket> prints C<  can't find end of headers>.

=item * Once we've read some headers, L<Perlbal::Socket> prints C<  pre-parsed headers: [$hstr]>.

=item * After reading headers, if there's additional content that we've read, we push it back; when we do so, L<Perlbal::Socket> prints C<  pushing back $len bytes after header>.

=item * If we got bogus headers, and right before we close the connection due to a parsing failure, L<Perlbal::Socket> prints C<  bogus headers>.

=item * If we got valid headers, L<Perlbal::Socket> prints C<  got valid headers>.

=item * If we're reading buffered data from a client, L<Perlbal::Socket> prints C<draining readbuf from $self to $dest: [$$bref]>.

=back


=head4 Debug level 4

By setting the debug level to 4 you get all the messages from levels 1 to 3.

Plus, C<write> is redefined so that whenever C<write> is called it first prints C<write($self, E<lt>$clenE<gt>"$content") from ($pkg, $filename, $line)>.

    PERLBAL_DEBUG = 4

=head3 PERLBAL_DEBUG_BUFFERED_UPLOADS

By setting this variable to 1 you can tell Perlbal to add a C<X-PERLBAL-BUFFERED-UPLOAD-REASON> header to requests that have to be buffered.

This can be useful to let your backend machine know that Perlbal is buffering the request.

The value of the header contains the reason why the request was buffered.


=head3 PERLBAL_DEBUG_OBJ

This is the variable you'll have to set to a true value in order to properly use the commands C<obj> or C<track>.

See L<Perlbal::Manual::Management> for more information.


=head3 PERLBAL_TEST_ALPHA

This is a variable used to test Perlbal's alpha features.

If you're a developer working on one of these features, first set the variable to a true value:

    PERLBAL_TEST_ALPHA = 1

And then, on your test file, use something like:

    unless ($ENV{PERLBAL_TEST_ALPHA}) {
        plan skip_all => 'Alpha feature; test skipped without $ENV{PERLBAL_TEST_ALPHA}';
        exit 0;
    } else {
        plan tests => 4;
    }


=head3 PERLBAL_TRACK_STATES

This is the variable you'll have to set to a true value in order to properly use the command C<state changes>.

See L<Perlbal::Manual::Management> for more information.


=head3 PERLBAL_XS_HEADERS

By setting to a true value you can enable L<Perlbal::XS::HTTPHeaders>, if installed.

Note that if you enable L<Perlbal::XS::HTTPHeaders> you won't have access to the fields of L<Perlbal::HTTPHeaders>.


=head3 TEST_PERLBAL_FOREGROUND

This variable is used by L<Perlbal::Test> to test Perlbal.

C<TEST_PERLBAL_FOREGROUND> with a true value tells L<Perlbal::Test> that it should run a server in the foreground.

See L<Perlbal::Test> for more information.


=head3 TEST_PERLBAL_USE_EXISTING

This variable is used by L<Perlbal::Test> to test Perlbal.

If C<TEST_PERLBAL_USE_EXISTING> is set to a true value then C<Perlbal::Test::start_server> will be return a socket which is connected to an existing server's management port.

See L<Perlbal::Test> for more information.


=head2 Setting up Perlbal

You can run C<perlbal> as a daemon:

    $ perlbal --daemon -c /home/user/perlbal.conf

B<--daemon> has the alias B<-d>.

A common practice is to create a C<perlbal.sh> file that supports the common operations you'll require (start, stop, restart) and place it under C</etc/init.d>.


=head2 SEE ALSO

L<Perlbal::Manual::Management>.
