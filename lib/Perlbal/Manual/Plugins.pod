=head1 NAME

Perlbal::Manual::Plugins - Creating and using plugins


=head2 VERSION

This document details Perlbal 1.76's system for Plugins.


=head2 How to use a plugin

...


=head2 How to create a plugin

A Perlbal plugin consists in a package under the Perlbal::Plugin namespace that implements a set of functions described below.


=head3 Creating a package

While there are many ways of creating a package, we'd recommend that you use something to do it for you. A good option is C<Module::Starter>.

(note: if you really want to, you can just create a file with your package and use it; by using something like C<Module::Starter> you're making sure that several pitfalls are avoided, lots of basic rules are followed and that your package can easily be made available as a distribution that you can deploy on any machine in a simple way)

Let's assume you want to create a plugin that checks requests for a X-Magic header and, if present, add an header X-Color to the response when serving a file. Let's assume your plugin will be called Perlbal::Plugin::ColorOfMagic.

Having installed C<Module::Starter>, here's a command you can run that will create your package for you:

    $ module-starter --module=Perlbal::Plugin::ColorOfMagic --author="My name" --email=my@email.address

That should create a file tree that you can get better acquainted to by reading C<Module::Starter>'s fine documentation. For this example, the file you really need should be C<lib/Perlbal/Plugin/ColorOfMagic.pm>.

This file probably starts with something like the following:

    package Perlbal::Plugin::ColorOfMagic;

    use warnings;
    use strict;

You'll have to add a few functions to this file. These are described below.

(note: upon creating this package, some boilerplate documentation will also be present on the file; you should revise it and even remove bits that don't feel right for your plugin)


=over 4

=item register

C<register> is called when the plugin is being added to a service. This is where you register your plugin's hooks.

For the sake of our example (C<Perlbal::Plugin::ColorOfMagic>, see above), what we want to do is register a hook that modifies the response headers; that means we want a C<modify_response_headers> hook.

Here's what you'd do:

    sub register {
        my ($class, $service) = @_;

        $service->register_hook('ColorOfMagic','modify_response_headers', sub {

            my Perlbal::ClientHTTPBase $cp = shift;

            if ( $cp->{req_headers}->header('X-Magic') ) {
                $cp->{res_headers}->header( 'X-Color', 'Octarine' );
            }

            return 0;
        });
    }

Inside C<register>, we're calling C<register_hook> to register our C<ColorOfMagic> C<modify_response_headers> hook. It's code, that will run "when we've set all the headers, and are about to serve a file" (see C<Perlbal::Manual::Hooks>), receives a C<Perlbal::ClientHTTPBase> object (you can see what kind of object your hook will receive on C<Perlbal::Manual::Hooks>). We're checking to see if C<X-Magic> is defined on the request and, if so, we're setting header C<X-Color> on the response to C<Octarine>.

Notice that the hook ends with C<return 0>. This is because returning a true value means that you want to cancel the connection to the backend and send the response to the client yourself.


=item unregister

C<unregister> is called when the plugin is removed from a service. It's a standard good practice to unregister your plugin's hooks here, like so:

    sub unregister {
        my ($class, $service) = @_;
        $service->unregister_hooks('ColorOfMagic');
        return 1;
    }

You can also use C<unregister_hook> to unregister one single hook:

    $service->unregister_hooks('ColorOfMagic', 'modify_response_headers');


=item load

C<load> is called when your plugin is loaded (or reloaded).

This is where you should perform your plugin's initialization, which can go from setting up some variables to registering a management command.

... # we must explain how to register management commands here ...

    my $color;

    sub load {
        $color = 'Octarine';

        return 1;
    }


C<load> must always be defined, but if you really don't need it you can have it simply returning a true value:

    sub load { return 1; }


=item unload

C<unload> is called when your plugin is unloaded. This is where you should perform any clean up tasks.

C<unload> must always be defined, but if you really don't need it you can have it simply returning a true value:

    sub unload { return 1; }

Don't forget to call C<unregister_global_hook> if you have registered any.


=item dumpconfig

When managing Perlbal (see C<Perlbal::Manual::Management>) you can send a C<dumpconfig> command that will result in a configuration dump.

Apart from the global configuration, each plugin that implements a C<dumpconfig> function will also have that function called.

C<dumpconfig> should return an array of messages to be displayed.

    sub dumpconfig {
        my ($class, $service) = @_;

        my @messages;

        push @messages, "COLOROFMAGIC is $color";

        return @messages;
    }

C<dumpconfig> is not required.


=back


=head3 management_command

...


=head3 register_setter

C<register_setter> allows you to defined parameters that can be set for your plugin, using a syntax such as:

    set my_service.my_plugin.my_variable = my_value

For instance:

    set discworld.colorofmagic.color = 'Orange'

Here's how you'd configure a new setter, by using C<register_setter> inside C<load>:

    my $color;

    sub load {
        $color = 'Octarine';


        $svc->register_setter('ColorOfMagic', 'color', sub {
            my ($out, $what, $val) = @_;
            return 0 unless $what && $val;

            $color = $val;

            $out->("OK") if $out;

            return 1;
        });


        return 1;
    }


=head3 register vs. load

...


=head2 Known plugins

The following is a list of known plugins:


=over 4

=item * Perlbal::Plugin::AccessControl (Perlbal core)

Basic access control based on IPs and Netmasks.


=item * Perlbal::Plugin::Addheader

Add Headers to Perlbal webserver responses.


=item * Perlbal::Plugin::AutoRemoveLeadingDir (Perlbal core)

Auto-removal of leading directory path components in the URL.


=item * Perlbal::Plugin::BackendHeaders

See which backend served the request.


=item * Perlbal::Plugin::Cgilike (Perlbal core)

Handle Perlbal requests with a Perl subroutine.


=item * Perlbal::Plugin::EchoService (Perlbal core)

Simple plugin demonstrating how to create an add-on service for Perlbal using the plugin infrastructure.


=item * Perlbal::Plugin::ExpandSSL

Add a custom header according to the SSL of a service.


=item * Perlbal::Plugin::ForwardedFor

Rename the X-Forwarded-For header in Perlbal.


=item * Perlbal::Plugin::Highpri (Perlbal core)

Makes some requests high priority.


=item * Perlbal::Plugin::Include (Perlbal core)

Allows multiple, nesting configuration files.


=item * Perlbal::Plugin::LazyCDN (Perlbal core)

Support for Content Delivery Networks.


=item * Perlbal::Plugin::MaxContentLength (Perlbal core)

Reject large requests.


=item * Perlbal::Plugin::NotModified (Perlbal core)

Automatic 304 Not Modified responses.


=item * Perlbal::Plugin::PSGI

PSGI web server on Perlbal.


=item * Perlbal::Plugin::Palimg (Perlbal core)

Plugin that allows Perlbal to serve palette altered images.


=item * Perlbal::Plugin::Queues (Perlbal core)

Simple queue length header inclusion plugin.


=item * Perlbal::Plugin::Redirect (Perlbal core)

Plugin to do redirecting in Perlbal land.


=item * Perlbal::Plugin::Stats (Perlbal core)

Basic Perlbal statistics gatherer.


=item * Perlbal::Plugin::StickySessions

Session affinity for perlbal.


=item * Perlbal::Plugin::TrustHeader

Remove untrusted headers.


=item * Perlbal::Plugin::UrlGroup

Let URL match it in regular expression.


=item * Perlbal::Plugin::Vhosts (Perlbal core)

Name-based virtual hosts.


=item * Perlbal::Plugin::Vpaths (Perlbal core)

Select by path (selector role only).


=back


=head2 SEE ALSO

C<Perlbal::Manual::Hooks>.
