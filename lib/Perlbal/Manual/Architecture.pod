=head1 NAME

Perlbal::Manual::Architecture - Perlbal's architecture at a glance

=head2 DESCRIPTION

Perlbal listens for UDP broadcasts from the web nodes describing how many available children they have. This information is then used to pick an endpoint for a backend connection to be made to in order to handle a user's incoming request.

                            {{ INTERNET }}
                                  |
                                  v
              [Service]<===>[TCPListener]
                          ___/    |    \___
                         v        v        v
             [ClientManage]  [ClientHTTP] [ClientProxy]
                                                ^
                                                |
                                                v
                                          [BackendHTTP]

So connections come in from wherever and get to the TCPListener. It uses Service objects to determine what kind of Client* to spawn. The Client classes then handle crafting the response for the user.


=head2 Classes

The following is a brief introduction/overview to all of Perlbal's classes:


=head3 Perlbal::Socket

Descends from Danga::Socket.

Adds on to the base class to provide some functionality specifically useful for creating HTTP sockets.

Perlbal::Socket has the following fields:

=over 4

=item headers_string

Headers as they're being read.


=item req_headers

The final Perlbal::HTTPHeaders object inbound.


=item res_headers

Response headers outbound (Perlbal::HTTPHeaders object).


=item create_time

Creation time.


=item alive_time

Last time noted alive.


=item state

General purpose state; used by descendants.


=item do_die

If on, die and do no further requests.


=item read_buf

Arrayref of scalarref read from client.


=item read_ahead

Bytes sitting in read_buf.


=item read_size

Total bytes read from client, ever.

=item ditch_leading_rn

If true, the next header parsing will ignore a leading \r\n.


=item observed_ip_string

If defined, contains the observed IP string of the peer we're serving. This is intended for holding the value of the X-Forwarded-For and using it to govern ACLs.


=back


=head3 Perlbal::TCPListener

Descends from Perlbal::Socket.

Very lightweight and fast connection accept class. Takes incoming connections as fast as possible and passes them off, instantiating one of the various Client* classes to handle it.

Perlbal::TCPListener has the following fields:

=over 4

=item service

Perlbal::Service.


=item hostport

Scalar IP port of where this service is listening for new connections.


=item sslopts

The SSL Options.

    use Data::Dumper;
    warn Dumper( $tcp_listener->{'sslopts'} );

The above lines would print something like the following:

    $VAR1 = {
              'ssl' => {
                         'SSL_cipher_list' => '...',
                         'SSL_cert_file' => '...',
                         'SSL_key_file' => ',,,',
                         'SSL_ca_path' => '...',
                         'SSL_verify_mode' => '...'
                       }
            };


=item v6

Boolean value stating whether the installation of Perlbal supports IPv6 (which basically boils down to C<Danga::Socket> v1.6.1 and C<IO::Socket::INET6> being available).


=back


=head3 Perlbal::BackendHTTP

Descends from Perlbal::Socket.

This class handles connections to the backend web nodes for getting data back to the user. This class is used by other classes such as ClientProxy to send a request to an internal node.

Perlbal::BackendHTTP has the following fields:

=over 4

=item client

Perlbal::ClientProxy connection, or undef.


=item service

Perlbal::Service.


=item pool

Perlbal::Pool; whatever pool we spawned from.


=item ip

IP scalar.


=item port

Port scalar.


=item ipport

C<$ip:$port>.


=item reportto

Object; must implement reporter interface.


=item has_attention

Has been accepted by a webserver and we know for sure we're not just talking to the TCP stack.


=item waiting_options

If true, we're waiting for an OPTIONS * response to determine when we have attention.


=item disconnect_at

Time this connection will be disconnected, if it's kept-alive and backend told us; otherwise C<undef> for unknown.


=item content_length

Length of document being transferred. Only applies when the backend server sends a content-length header.


=item content_length_remain

Bytes remaining to be read. Only applies when the backend server sends a content-length header.


=item use_count

Number of requests this backend's been used for.


=item generation

Int; counts what generation we were spawned in.


=item buffered_upload_mode

Boolean. If on, we're doing a buffered upload transmit.


=item scratch

Extra storage; plugins can use it if they want.


=back


=head3 Perlbal::HTTPHeaders

Header management. Parses headers (request and response) and stores data for further user. Also manages validation of the request line so that it conforms to HTTP specifications.

Perlbal::HTTPHeaders has the following fields:

=over 4

=item headers

href; lowercase header -> comma-sep list of values.


=item origcase

Href; lowercase header -> provided case.


=item hdorder

Aref; order headers were received (canonical order).


=item method

Scalar; request method (if GET request).


=item uri

Scalar; request URI (if GET request).


=item type

C<res> or C<req>.


=item code

HTTP response status code.


=item codetext

Status text that for response code.


=item ver

Version (string) "1.1".


=item vernum

Version (number: major*1000+minor): "1.1" => 1001.


=item responseLine

First line of HTTP response (if response).


=item requestLine

First line of HTTP request (if request).


=back


=head3 Perlbal::ClientHTTPBase

Descends from Perlbal::Socket.

Provides base functionality to ClientHTTP and ClientProxy. Notably, the ability to efficiently send files to the remote user. Also handles most of the state logic for statistics and such. Is also used for services of type C<selector>. The ClientHTTPBase then reads in the request headers, and asks the service to re-bless the client instance to a more specific type, for either a ClientProxy or ClientHTTP (depending on selector's mapping).

Perlbal::ClientHTTPBase has the following fields:

=over 4


=item service

Perlbal::Service object.


=item replacement_uri

URI to send instead of the one requested; this is used to instruct C<_serve_request> to send an index file instead of trying to serve a directory and failing.


=item scratch

Extra storage; plugins can use it if they want.


=item reproxy_file

Filename the backend told us to start opening.


=item reproxy_file_size

Size of file, once we C<stat()> it.


=item reproxy_fh

If needed, C<IO::Handle> of fd.


=item reproxy_file_offset

How much we've sent from the file.


=item post_sendfile_cb

Subref to run after we're done sendfile'ing the current file.


=item requests

Number of requests this object has performed for the user.


=item selector_svc

The original service from which we came.


=item is_ssl

Whether the socket was SSL attached (restricted operations).


=back


=head3 Perlbal::ClientHTTP

Descends from Perlbal::ClientHTTPBase.

Very simple and lightweight class. Handles sending files to the user without much overhead. Most of the functionality is contained in the parent class, and this class doesn't implement much new stuff.

Perlbal::ClientHTTP has the following fields:

=over 4

=item put_in_progress

1 when we're currently waiting for an async job to return.


=item put_fh

File handle to use for writing data.


=item put_fh_filename

Filename of put_fh.


=item put_pos

File offset to write next data at.


=item content_length

Length of document being transferred.


=item content_length_remain

Bytes remaining to be read.


=item chunked_upload_state

Boolean/obj: if processing a chunked upload, Perlbal::ChunkedUploadState object, else undef.


=back


=head3 Perlbal::ClientProxy

Descends from Perlbal::ClientHTTPBase.

Takes an incoming connection from a user and connects to a backend node (C<BackendHTTP>) and relays the request. The backend can then either tell the proxy to reproxy and load a file from disk, or return a file directly, or just return a status message.

Perlbal::ClientProxy has the following fields:

=over 4

=item backend

Perlbal::BackendHTTP object (or C<undef> if disconnected).


=item backend_requested

True if we've requested a backend for this request.


=item reconnect_count

Number of times we've tried to reconnect to backend.


=item high_priority

Boolean; 1 if we are or were in the high priority queue.


=item low_priority

Boolean; 1 if we are or were in the low priority queue.


=item reproxy_uris

Arrayref; URIs to reproxy to, in order.


=item reproxy_expected_size

Int: size of response we expect to get back for reproxy.


=item currently_reproxying

Arrayref; the host info and URI we're reproxying right now.


=item content_length_remain

Int: amount of data we're still waiting for.


=item responded

Bool: whether we've already sent a response to the user or not.


=item last_request_time

Int: time that we last received a request.


=item primary_res_hdrs

If defined, we are doing a transparent reproxy-URI and the headers we get back aren't necessarily the ones we want. Instead, get most headers from the provided C<res> headers object here.


=item is_buffering

Bool; if we're buffering some/all of a request to memory/disk.


=item is_writing

Bool; if on, we currently have an C<aio_write> out.


=item start_time

Hi-res time when we started getting data to upload.


=item bufh

Buffered upload filehandle object.


=item bufilename

String; buffered upload filename.


=item bureason

String; if defined, the reason we're buffering to disk.


=item buoutpos

Int; buffered output position.


=item backend_stalled

Boolean: if backend has shut off its reads because we're too slow.


=item unread_data_waiting

Boolean: if we shut off reads while we know data is yet to be read from client.


=item chunked_upload_state

Bool/obj: if processing a chunked upload, Perlbal::ChunkedUploadState object, else undef.


=item request_body_length

Integer: request's body length, either as-declared, or calculated after chunked upload is complete.


=item last_upload_packet

Unixtime we last sent a UDP upload packet. For perlbal sending out UDP packets related to upload status (for xmlhttprequest upload bar).


=item upload_session

Client's self-generated upload session. For perlbal sending out UDP packets related to upload status (for xmlhttprequest upload bar).


=item retry_count

Number of times we've retried this request so far after getting 500 errors.


=back


=head3 Perlbal::ClientManage

Descends from Perlbal::Socket.

Simple interface that provides a way for users to use the management interface of Perlbal. You can connect to the management port (as defined in the config file) with a web browser or regular telnet (see C<Perlbal::Manual::Management> for more information on this).

Perlbal::ClientManage has the following fields:

=over 4

=item service

Perlbal::Service.


=item buf

...


=item is_http

Boolean stating whether the request is HTTP.


=item ctx

Perlbal::CommandContext.


=back


=head3 Perlbal::Service

A service is a particular item that Perlbal is doing. Services can have a role which defines how they behave. Each service can also have a bunch of parameters set to further adjust its behavior. By itself, the Service class handles maintaining pools of backend connections and managing statistics about itself.

Perlbal::Service has the following fields:

=over 4

=item ...

...


=back
